# 데이터베이스 스키마 자동 생성

---
* DDL을 애플리케이션 실행 시점에 자동 생성
* 테이블 중심 -> 객체 중심
* 데이터베이스 방언(Dialect)을 활용하여 데이터베이스에 맞는 적절한 DDL 생성
* 이렇게 __생성된 DDL은 '개발'에서만 사용__ : 운영에서 쓰면 큰 사고난다...
* 생성된 DDL은 운영서버에서 사용하지 않거나, 적절히 다듬은 후 사용
---

* *.yml 예시
```yaml
spring:
  ...
  
  jpa:
    hibernate:
      ddl-auto: create, update, none, etc...
```
---

### __ddl-auth option__
1. __create__ <br>기존테이블 삭제 후 다시 생성(DROP -> CREATE)
2. __create-dtop__ <br>create와 같으나 종료시점에 테이블 DROP
3. __update__ <br>변경된 부분만 반영 (생성된 부분을 __지우는건 불가능__ 함)
4. __validate__ <br>엔티티와 테이블이 __정상적으로 매핑되었는지__  만 확인
5. __none__ <br>사용하지 않음

---

### 주의 사항
* 당연하지만, 운영 장비에는 절대 create, create-drop, update를 사용하면 __안 된다.__
* 개발 초기 단계는 (__내 로컬..__) create 또는 update를 보편적으로 사용 함
* __테스트 서버__ 는 update 또는 validate를 사용하는 것을 권장 함<br> - 나만 사용하는 서버가 아님<br> - 어지간하면 __개발서버도 update는 안 하는게 좋음__...
* __스테이징과 운영 서버__ 는 validate 또는 none을 권장 함

---

* 데이터가 많으면 alter 하나에 시간이 엄청 오래걸릴 수 있고, 잘못하면 Database가 뻗을 수 있음
* none-lock으로 alter를 하더라도 리소스는 엄청 잡아먹음.. 근데 이건 alter 쿼리를 직접 짜서 날려야겠지?
* 어지간해서는 alter같은 명령어는 직접 데이터베이스에서(=개발계 또는 로컬) 실행해보고 문제가 없으면 DBA 검증 후에 운영에 반영하는 것이 좋음
* 개발자들이 힘들게 셋팅해둔 개발계에서 잘못해서 create가 돌아서 모두 drop해버린다면... 운영에서는 당연히 매우 큰 문제지만 개발계도 슬퍼진다...